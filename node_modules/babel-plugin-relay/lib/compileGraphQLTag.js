/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 * @oncall relay
 */

'use strict';

var crypto = require('crypto');
var _require = require('graphql'),
  print = _require.print;
var _require2 = require('path'),
  dirname = _require2.dirname,
  joinPath = _require2.join,
  relativePath = _require2.relative,
  resolvePath = _require2.resolve;
var GENERATED = './__generated__/';

/**
 * Given a graphql`` tagged template literal, replace it with the appropriate
 * runtime artifact.
 */
function compileGraphQLTag(t, path, state, ast) {
  var _state$opts$eagerEsMo, _state$opts, _state$opts2, _state$opts3, _state$opts4, _state$opts$codegenCo, _state$opts5;
  if (ast.definitions.length !== 1) {
    throw new Error('BabelPluginRelay: Expected exactly one definition per graphql tag.');
  }
  var definition = ast.definitions[0];
  if (definition.kind !== 'FragmentDefinition' && definition.kind !== 'OperationDefinition') {
    throw new Error('BabelPluginRelay: Expected a fragment, mutation, query, or ' + 'subscription, got `' + definition.kind + '`.');
  }
  var eagerEsModules = (_state$opts$eagerEsMo = (_state$opts = state.opts) === null || _state$opts === void 0 ? void 0 : _state$opts.eagerEsModules) !== null && _state$opts$eagerEsMo !== void 0 ? _state$opts$eagerEsMo : false;
  var isHasteMode = ((_state$opts2 = state.opts) === null || _state$opts2 === void 0 ? void 0 : _state$opts2.jsModuleFormat) === 'haste';
  var isDevVariable = (_state$opts3 = state.opts) === null || _state$opts3 === void 0 ? void 0 : _state$opts3.isDevVariableName;
  var artifactDirectory = (_state$opts4 = state.opts) === null || _state$opts4 === void 0 ? void 0 : _state$opts4.artifactDirectory;
  var buildCommand = (_state$opts$codegenCo = (_state$opts5 = state.opts) === null || _state$opts5 === void 0 ? void 0 : _state$opts5.codegenCommand) !== null && _state$opts$codegenCo !== void 0 ? _state$opts$codegenCo : 'relay-compiler';
  // Fallback is 'true'
  var isDevelopment = (process.env.BABEL_ENV || process.env.NODE_ENV) !== 'production';
  return createNode(t, state, path, definition, {
    artifactDirectory: artifactDirectory,
    eagerEsModules: eagerEsModules,
    buildCommand: buildCommand,
    isDevelopment: isDevelopment,
    isHasteMode: isHasteMode,
    isDevVariable: isDevVariable
  });
}

/**
 * The Relay compiler generates separate modules that contain the compiled code.
 * Here we generate:
 *  - a memoized `require` call for that generated code
 *  - for development mode, runtime validation that the artifacts are up to date
 */
function createNode(t, state, path, graphqlDefinition, options) {
  var definitionName = graphqlDefinition.name && graphqlDefinition.name.value;
  if (!definitionName) {
    throw new Error('GraphQL operations and fragments must contain names');
  }
  var requiredFile = definitionName + '.graphql';
  var requiredPath = options.isHasteMode ? requiredFile : options.artifactDirectory ? getRelativeImportPath(state, options.artifactDirectory, requiredFile) : GENERATED + requiredFile;
  var hash = crypto.createHash('md5').update(print(graphqlDefinition), 'utf8').digest('hex');
  var topScope = path.scope;
  while (topScope.parent) {
    topScope = topScope.parent;
  }
  var id = topScope.generateUidIdentifier(definitionName);
  var expHash = t.MemberExpression(id, t.Identifier('hash'));
  var expWarn = warnNeedsRebuild(t, definitionName, options.buildCommand);
  var expWarnIfOutdated = t.LogicalExpression('&&', expHash, t.LogicalExpression('&&', t.BinaryExpression('!==', expHash, t.StringLiteral(hash)), expWarn));
  if (options.eagerEsModules) {
    var importDeclaration = t.ImportDeclaration([t.ImportDefaultSpecifier(id)], t.StringLiteral(requiredPath));
    var program = path.findParent(function (parent) {
      return parent.isProgram();
    });
    program.unshiftContainer('body', importDeclaration);
    var expAssignAndCheck = t.SequenceExpression([expWarnIfOutdated, id]);
    var expAssign;
    if (options.isDevVariable != null) {
      expAssign = t.ConditionalExpression(t.Identifier(options.isDevVariable), expAssignAndCheck, id);
    } else if (options.isDevelopment) {
      expAssign = expAssignAndCheck;
    } else {
      expAssign = id;
    }
    path.replaceWith(expAssign);
  } else {
    topScope.push({
      id: id
    });
    var requireGraphQLModule = t.CallExpression(t.Identifier('require'), [t.StringLiteral(requiredPath)]);
    var expAssignProd = t.AssignmentExpression('=', id, requireGraphQLModule);
    var _expAssignAndCheck = t.SequenceExpression([expAssignProd, expWarnIfOutdated, id]);
    var _expAssign;
    if (options.isDevVariable != null) {
      _expAssign = t.ConditionalExpression(t.Identifier(options.isDevVariable), _expAssignAndCheck, expAssignProd);
    } else if (options.isDevelopment) {
      _expAssign = _expAssignAndCheck;
    } else {
      _expAssign = expAssignProd;
    }
    var expVoid0 = t.UnaryExpression('void', t.NumericLiteral(0));
    path.replaceWith(t.ConditionalExpression(t.BinaryExpression('!==', id, expVoid0), id, _expAssign));
  }
}
function warnNeedsRebuild(t, definitionName, buildCommand) {
  return t.callExpression(t.memberExpression(t.identifier('console'), t.identifier('error')), [t.stringLiteral("The definition of '".concat(definitionName, "' appears to have changed. Run ") + '`' + buildCommand + '` to update the generated files to receive the expected data.')]);
}
function getRelativeImportPath(state, artifactDirectory, fileToRequire) {
  if (state.file == null) {
    throw new Error('Babel state is missing expected file name');
  }
  var filename = state.file.opts.filename;
  var relative = relativePath(dirname(filename), resolvePath(artifactDirectory));
  var relativeReference = relative.length === 0 || !relative.startsWith('.') ? './' : '';
  return relativeReference + joinPath(relative, fileToRequire);
}
module.exports = compileGraphQLTag;